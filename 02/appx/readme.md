# Циклические коды выявляющие и исправляющие ошибки

## Термины

k - количество символов кодируемого сообщения (называемого также информационным словом);

n - полная длина кодового слова, включающего в себя кодируемые данные и символы четности;

(n-k) – количество символов четности; 

t - максимальное количество исправляемых ошибок;


2t - общее количество символов четности, т.к. для исправления одной ошибки требуется два символа четности;

RS(n, k) - описывает определенную разновидность корректирующих кодов Рида-Соломона, оперирующую с n-символьными блоками, k-символов, из которых представляют полезные данные, а все остальные задействованы под символы четности.

a - примитивный полином. Полином, порожденный на основе примитивного члена a, называется порожденным или сгенерированным (generate) полиномом.

##

Существует два типа циклических кодеров: несистематические и систематические кодировщики.

Вычисление несистематических корректирующих кодов осуществляется умножением информационного слова на порожденный полином, в результате чего образуется кодовое слово, полностью отличающееся от исходного информационного слова, а потому для непосредственного употребления категорически непригодное. Для приведения полученных данных в исходный вид мы должны в обязательном порядке выполнить ресурсоемкую операцию декодирования, даже если данные не искажены и не требуют восстановления!

При систематическом кодировании, напротив, исходное информационное слово останется неизменным, а корректирующие коды (часто называемые символами четности) добавляются в его конец, благодаря чему к операции декодирования приходится прибегать лишь в случае действительного разрушения данных. Вычисление несистематических корректирующих кодов Рида-Соломона осуществляется делением информационного слова на порожденный полином. При этом все символы информационного слова сдвигаются на n – k байт влево, а на освободившееся место записывается 2t байт остатка .

![Устройство кодового слова](/img/rs_1.gif)

Поскольку рассмотрение обоих типов кодировщиков заняло бы слишком много места, сосредоточим свое внимание на одних лишь систематических кодерах как на наиболее популярных.

Архитектурно кодировщик представляет собой совокупность сдвиговых регистров (shift registers), объединенных посредством сумматоров и умножителей, функционирующих по правилам арифметики Галуа. Сдвиговый регистр (иначе называемый регистром сдвига) представляет последовательность ячеек памяти, называемых разрядами, каждый из которых содержит один элемент поля Галуа GF(q). Содержащийся в разряде символ, покидая этот разряд, «выстреливается» на выходную линию. Одновременно с этим разряд «засасывает» символ, находящийся на его входной линии. Замещение символов происходит дискретно, в строго определенные промежутки времени, называемые тактами.

При аппаратной реализации сдвигового регистра его элементы могут быть объединены как последовательно, так и параллельно. При последовательном объединении пересылка одного m-разрядного символа потребуем m-тактов, в то время как при параллельном она осуществляется всего за один такт.

Цепи, основанные на регистрах сдвига, обычно называют фильтрами. Блок-схема фильтра, осуществляющего деление полинома на константу, приведена ниже. Деление реализуется посредством умножения и сложения. Данный прием базируется на вычислении системы двух рекуррентных равенств:

![Деление полинома на константу посредством умножения и сложения](/img/rs_2.gif)

Здесь: Q(r)(x) и R(r)(x) – соответственно частное и остаток на r-шаге рекурсии. Поскольку сложение и вычитание, выполняемое по модулю два, тождественны друг другу, для реализации делителя нам достаточно иметь всего два устройства – устройство сложения и устройство умножения, а без устройства вычитания можно обойтись.

После n-сдвигов на выходе регистра появляется частное, а в самом регистре окажется остаток, который и представляет собой рассчитанные символы четности, а коэффициенты умножения с g0 по g(2t – 1) напрямую соответствуют коэффициентам умножения порожденного полинома.

![Устройство простейшего кодера](/img/rs_3.jpg)


# Проверочный циклический код CRC

Контрольная сумма - способ проверки неизвенности данных, передаваемых по каналам связи или хранящихся в в долговременных системах хранения данных. В условиях, когда достаточным является обнаружение самого факта искажения данных, широкое распространение получили алгоритмы, основанные на циклически избыточных кода (Cyclic redundancy code - CRC).

## Алгоритм вычисления CRC кода

В основе алгоритма CRC также лежит задача решения уравнения: 

B(x) = Q(x)*G(x) + R(x), а именно

- исходный текст из последовательности бит представляется в виде двоичного полинома B(x) над полем Галуа FG(2);
- выбирается некоторый порождающий полином G(x) степени (r+1);
- вычисляется остаток R(x) от деления полинома B(x) на порождающий G(x), при этом частное Q(x) от деления отбрасывается.

Остаток R(x) и является искомой контрольной суммой, сопровождающей защищаемый объект. Проверка контрольной суммы выполняется повторным её вычислением и сравнением с сохраненной.
    
Наивный алгоритм вычисления CRC32 представлен ниже:

```
// ---------------------------- reverse --------------------------------

// Reverses (reflects) bits in a 32-bit word.
unsigned reverse(unsigned x) {
   x = ((x & 0x55555555) <<  1) | ((x >>  1) & 0x55555555);
   x = ((x & 0x33333333) <<  2) | ((x >>  2) & 0x33333333);
   x = ((x & 0x0F0F0F0F) <<  4) | ((x >>  4) & 0x0F0F0F0F);
   x = (x << 24) | ((x & 0xFF00) << 8) |
       ((x >> 8) & 0xFF00) | (x >> 24);
   return x;
}

// ----------------------------- crc32a --------------------------------

/* This is the basic CRC algorithm with no optimizations. It follows the
logic circuit as closely as possible. */

unsigned int crc32a(unsigned char *message) {
   int i, j;
   unsigned int byte, crc;

   i = 0;
   crc = 0xFFFFFFFF;
   while (message[i] != 0) {
      byte = message[i];            // Get next byte.
      byte = reverse(byte);         // 32-bit reversal.
      for (j = 0; j <= 7; j++) {    // Do eight times.
         if ((int)(crc ^ byte) < 0)
              crc = (crc << 1) ^ 0x04C11DB7;
         else crc = crc << 1;
         byte = byte << 1;          // Ready next msg bit.
      }
      i = i + 1;
   }
   return reverse(~crc);
}
```

В данном примере порождяющим является полином 0x104C11DB7 или x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0. Данный полином использвется в алгоритме архивации данных Zip

![Значение CRC архиваторе 7z](/img/crc_1.gif)



# Коды Рида-Соломона

В кодах Рида-Соломона сообщение представляется в виде набора символов некоторого алфавита. Собственно говоря, в качестве алфавита используется поле Галуа. То есть если мы хотим закодировать сообщение, представленное двоичным кодом, то мы разбиваем его (в случае, если мы используем наше поле Галуа из 16 элементов) на группы по 4 бита и дальше работаем с каждой группой как с числом из этого поля Галуа.

При построении кода Рида-Соломона задаётся пара чисел N, K, где N – общее количество символов, а K – «полезное» количество символов, остальные N-K символов представляют собой избыточный код, предназначенный для восстановления ошибок.

Такой код Галуа будет иметь так называемое «расстояние Хэмминга» D = N – K +1. В соответствии с теорией кодирования, код, имеющий расстояние Хемминга D = 2t+1, позволяет восстанавливать t ошибок. Таким образом, если в наше кодовое слово случайно внести t = (N-K)/2 ошибок (т.е. просто произвольно заменить значения t символов любыми значениями), то окажется возможным обнаружить и исправить эти ошибки.
Сообщения при кодировании Рида-Соломона представляются полиномами. Исходное сообщение представляется как коэффициенты полинома p(x) степени K-1, имеющего (разумеется!) K коэффициентов. Важную роль играет порождающий многочлен Рида-Соломона, g(x), который строится следующим образом:

g(x) = (x+a^1)(x+a^2)….(x+a^(D-1))

Здесь a – это примитивный член. Учтя, что операция сложения равносильна операции вычитания, что a1, a2.. aD-1 - являются корнями этого многочлена.

Например, построим порождающий многочлен кода Рида-Соломона с N = 15, K = 9: 

g(x) = (x+2)(x+22)(x+23)(x+24)(x+25)(x+26) = x6+7x5+9x4+3x3+12x2+10x+12.

Возведения в степень и умножения выполнены по правилам поля Галуа. Все дальнейшие примеры тоже будут использовать этот код; как нетрудно видеть, этот код будет способен исправлять до трёх ошибок: (15 – 9 ) / 2 = 3.

Систематический код Рида-Соломона строится следуюзим образом:
- Сначала полином сдвигается на K коэффициентов влево
   p’(x) = p(x) * x(N-k)

а потом вычисляется его остаток от деления на порождающий полином и прибавляется к p’(x):
   C(x) = p’(x) + p’(x) mod g(x)

Другими словами, сообщение «сдвигается» на N-K символов - так, что его полином имеет такие коэффициенты: (m8, m7, m6, m5, m4, m3, m2, m1, m0, 0,0,0,0,0,0) (m0.. m8 - символы сообщения).

Далее этот полином делится с остатком на порождающий полином g(x), в результате чего в остатке получается полином степени (N-K-1) с N-k коэффициентами.

Этот полином прибавляется к исходному полиному, сдвинутому на N-K символов (т.е. коэффициенты остатка как раз занимают место нулей). Для систематического кода очевидно, что K старших коэффициентов полученного кода C(x) содержат исходное сообщение. Это удобно при декодировании, поэтому в дальнейшем будем рассматривать именно систематический вариант.

Закодированное сообщение C(x) обладает очень важным свойством: оно без остатка делится на порождающий многочлен g(x).

Алгоритмически кодирование реализуется сдвиговым регистром, после n-сдвигов на выходе регистра появляется частное, а в самом регистре окажется остаток, который и представляет собой рассчитанные символы четности (они же – коды Рида-Соломона), а коэффициенты умножения с g0 по g(2t – 1) напрямую соответствуют коэффициентам умножения порожденного полинома.

## Кодировщик (encoder)

Низкая эффективность программных реализаций кодеров Рида-Соломона объясняется тем, что разработчик не может осуществлять параллельное объединение элементов сдвигового регистра и вынужден работать с той шириной разрядности, которую «навязывает» архитектура данной машины. Однако создать 4-элементный 8-битный регистр сдвига параллельного типа на процессорах семейства IA32 вполне реально.

Простейший пример программной реализации такого фильтра приведен ниже. Это законченный кодер Рида-Соломона, вполне пригодный для практического использования. Конечно, при желании его можно было бы и улучшить, но тогда неизбежно пострадала бы наглядность и компактность листинга.

```
// Исходный текст простейшего кодера Рида-Соломона (Марк Русинович)
/*-----------------------------------------------------------------------------------------------------
*
*                           кодировщик Рида-Соломона
*                           ========================
*
* кодируемые данные передаются через массив data[i], где i=0..(k-1), а сгенерированные символы четности
* заносятся в массив b[0]..b[2*t-1]. Исходные и результирующие данные должны быть представлены
* в полиномиальной форме (т.е. в обычной форме машинного представления данных). 
* Кодирование производится с использованием сдвигового feedback-регистра, заполненного соответствующими
* элементами массива g[] с порожденным полиномом внутри, процедура генерации которого уже обсуждалась
* в предыдущей статье. Сгенерированное кодовое слово описывается следующей формулой:
* с(x) = data(x)*x(n-k) + b(x)
*
*          на основе исходных текстов Simon Rockliff, от 26.06.1991, распространяемых
*          по лицензии GNU
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––---------------------------------------------*/
encode_rs()
{
   int i, j;
   int feedback; 
   // инициализируем поле бит четности нулями
   for (i = 0; i < n - k; i++) 
      b[i] = 0;
   // обрабатываем все символы исходных данных справа налево
   for (i = k - 1; i >= 0; i--)
   {
      // готовим (data[i] + b[n – k –1]) к умножению на g[i], т.е. складываем очередной «захваченный»
      // символ исходных данных с младшим символом битов четности (соответствующего «регистру» b2t-1,
      // см. рис. 2) и переводим его в индексную форму, сохраняя результат в регистре feedback,
      // как мы уже говорили, сумма двух индексов есть произведение полиномов
      feedback = index_of[data[i] ^ b[n – k - 1]];  
      // есть еще символы для обработки?
      if (feedback != -1)
      {
         // осуществляем сдвиг цепи bx-регистров
         for (j=n-k-1; j>0; j--)
            // если текущий коэффициент g – это действительный (т.е. ненулевой коэффициент,
            // то умножаем feedback на соответствующий g-коэффициент и складываем его
            // со следующим элементом цепочки
            if (g[j]!=-1) 
               b[j]=b[j-1]^alpha_to[(g[j]+feedback)%n];
            else
               // если текущий коэффициент g – это нулевой коэффициент, выполняем один лишь
               // сдвиг без умножения, перемещая символ из одного m-регистра в другой
               b[j] = b[j-1];      
         // закольцовываем выходящий символ в крайний левый b0-регистр
         b[0] = alpha_to[(g[0]+feedback)%n];
     }
     else
     {  
         // деление завершено, осуществляем последний сдвиг регистра, на выходе регистра
         // будет частное, которое теряется, а в самом регистре – искомый остаток
         for (j = n-k-1; j>0; j--) 
            b[j] = b[j-1]; 
         b[0] = 0;
     }
   }
}
```

## Декодер (decoder)

Декодирование кодов Рида-Соломона представляет собой довольно сложную задачу, решение которой выливается в громоздкий, запутанный и чрезвычайно ненаглядный программный код, требующий от разработчика обширных знаний во многих областях высшей математики. Типовая схема декодирования, получившая название авторегрессионого спектрального метода декодирования, состоит из следующих шагов:

- вычисления синдрома ошибки (синдромный декодер);
- построения полинома ошибки, осуществляемое либо посредством высокоэффективного, но сложно реализуемого алгоритма Берлекэмпа-Месси, либо посредством простого, но медленного Евклидового алгоритма;
- нахождения корней данного полинома, обычно решающееся лобовым перебором (алгоритм Ченя);
- определения характера ошибки, сводящееся к построению битовой маски, вычисляемой на основе обращения алгоритма Форни или любого другого алгоритма обращения матрицы;
- наконец, исправления ошибочных символов путем наложения битовой маски на информационное слово и последовательного инвертирования всех искаженных бит через операцию XOR.

![Схема авторегрессионного спектрального декодера корректирующих кодов Рида-Соломона](/img/rs_4.gif)

## Синдромный декодер

Грубо говоря, синдром есть остаток деления декодируемого кодового слова c(x) на порожденный полином g(x), и, если этот остаток равен нулю, кодовое слово считается неискаженным. Ненулевой остаток свидетельствует о наличии по меньшей мере одной ошибки. Остаток от деления дает многочлен, не зависящий от исходного сообщения и определяемый исключительно характером ошибки (syndrome – греческое слово, обозначающее совокупность признаков и/или симптомов, характеризующих заболевание).

Принятое кодовое слово v с компонентами vi = ci + ei, где i = 0, … n – 1, представляет собой сумму кодового слова c и вектора ошибок e. Цель декодирования состоит в очистке кодового слова от вектора ошибки, описываемого полиномом синдрома и вычисляемого по формуле:  Sj = v(aj+j0–1), где j изменяется от 1 до 2t, а a представляет собой примитивный член «альфа». Да, мы снова выражаем функцию деления через умножение, поскольку деление – крайне неэффективная в смысле производительности операция.

Блок-схема устройства, осуществляющего вычисление синдрома, приведена ниже. Как видно, она представляет собой типичный фильтр.

![Блок-схема цепи вычисления синдрома](/img/rs_5.gif)

Вычисление синдрома ошибки происходит итеративно, так что вычисление результирующего полинома (также называемого ответом от английского «answer») завершается непосредственно в момент прохождения последнего символа четности через фильтр. Всего требуется 2t циклов «прогона» декодируемых данных через фильтр, – по одному прогону на каждый символ результирующего полинома.

## Полином локатора ошибки

Полученный синдром описывает конфигурацию ошибки, но еще не говорит нам, какие именно символы полученного сообщения были искажены. Действительно, степень синдромного полинома, равная 2t, много меньше степени полинома сообщения, равной n, и между их коэффициентами нет прямого соответствия. Полином, коэффициенты которого напрямую соответствуют коэффициентам искаженных символов, называется полиномом локатора ошибки и по общепринятому соглашению обозначается греческой буквой L (лямбда).

Если количество искаженных символов не превышает t, между синдромом и локатором ошибки существует следующее однозначное соответствие, выражаемое следующей формулой НОД[xn-1, E(x)] = L(x), и вычисление локатора сводится к задаче нахождения наименьшего общего делителя, успешно решенной еще Евклидом и элементарно реализуемой как на программном, так и на аппаратном уровне. Правда, за простоту реализации нам приходится расплачиваться производительностью, точнее непроизводительностью данного алгоритма, и на практике обычно применяют более эффективный, но и более сложный для понимания алгоритм Берлекэмпа-Месси (Berlekamp-Massy), подробно описанный Кнутом во втором томе «Искусства программирования» (см. также «Теория и практика кодов, контролирующих ошибки» Блейхута) и сводящийся к задаче построения цепи регистров сдвига с линейной обратной связью и по сути своей являющегося разновидностью авторегрессионого фильтра, множители в векторах которого и задают полином L.

Декодер, построенный по такому алгоритму, требует не более 3t операций умножения в каждой из итерации, количество которых не превышает 2t. Таким образом, решение поставленной задачи укладывается всего в 6t2 операций умножения. Фактически поиск локатора сводится к решению системы из 2t уравнений – по одному уравнению на каждый символ синдрома – c t неизвестными. Неизвестные члены и есть позиции искаженных символов в кодовом слове v. Легко видеть, если количество ошибок превышает t, система уравнений становится неразрешима и восстановить разрушенную информацию в этом случае не представляется возможным.

![Структурная схема алгоритма Берлекэмпа-Месси](/img/rs_6.gif)

## Корни полинома

Коль скоро полином локатора ошибки нам известен, его корни определяют местоположение искаженных символов в принятом кодовом слове. Остается эти корни найти. Чаще всего для этого используется процедура Ченя (Chien search), аналогичная по своей природе обратному преобразованию Фурье и фактически сводящаяся к тупому перебору (brute force, exhaustive search) всех возможных вариантов. Все 2m возможных символов один за другим подставляются в полином локатора в порядке социалистической очереди и затем выполняется расчет полинома. Если результат обращается в ноль – считается, что искомые корни найдены.

## Восстановление данных

Итак, мы знаем, какие символы кодового слова искажены, но пока еще не готовы ответить на вопрос: как именно они искажены. Используя полином синдрома и корни полинома локатора, мы можем определить характер разрушений каждого из искаженных символов. Обычно для этой цели используется алгоритм Форни (Forney), состоящий из двух стадий: сначала путем свертки полинома синдрома полиномом локатора L мы получаем некоторый промежуточный полином, условно обозначаемый греческой буквой W. Затем на основе W-полинома вычисляется нулевая позиция ошибки (zero error location), которая в свою очередь делится на производную от L-полинома. В результате получается битовая маска, каждый из установленных битов которой соответствует искаженному биту и для восстановления кодового слова в исходный вид все искаженные биты должны быть инвертированы, что осуществляется посредством логической операции XOR.

На этом процедура декодирования принятого кодового слова считается законченной. Остается отсечь n – k символов четности, и полученное информационное слово готово к употреблению.

## Исходный текст декодера

Ниже приводится исходный текст полноценного декодера Рида-Соломона.

```
//Исходный текст простейшего декодера Рида-Соломона (Марк Русинович)
/*-----------------------------------------------------------------------------------------------------
*
*                                     декодер Рида-Соломона
*                                     =====================
*
* Процедура декодирования кодов Рида-Соломона состоит из нескольких шагов: сначала мы вычисляем
* 2t-символьный синдром путем постановки alpha**i в recd(x), где recd – полученное кодовое слово,
* предварительно переведенное в индексную форму. По факту вычисления recd(x) мы записываем
* очередной символ синдрома в s[i], где i принимает значение от 1 до 2t, оставляя s[0] равным нулю.
* Затем, используя итеративный алгоритм Берлекэмпа, мы находим полином локатора ошибки – elp[i].
* Если степень elp превышает собой величину t, мы бессильны скорректировать все ошибки и ограничиваемся
* выводом сообщения о неустранимой ошибке, после чего совершаем аварийный выход из декодера.
* Если же степень elp не превышает t, мы подставляем alpha**i, где i = 1..n в elp для вычисления
* корней полинома. Обращение найденных корней дает нам позиции искаженных символов. Если количество
* определенных позиций искаженных символов меньше степени elp, искажению подверглось более чем t
* символов и мы не можем восстановить их. Во всех остальных случаях восстановление оригинального
* содержимого искаженных символов вполне возможно. В случае, когда количество ошибок заведомо велико,
* для их исправления декодируемые символы проходят сквозь декодер без каких-либо изменений.
*
*          на основе исходных текстов Simon Rockliff, от 26.06.1991, распространяемых по лицензии GNU
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––--------------------------------------------*/
decode_rs()
{
	int i, j, u, q;
	int s[n - k + 1];          // полином синдрома ошибки
	int elp[n – k + 2][n - k]; // полином локатора ошибки лямбда
	int d[n - k + 2];
	int l[n - k + 2];
	int u_lu[n - k + 2];
	int count = 0, syn_error = 0, root[t], loc[t], z[t + 1], err[n], reg[t + 1];
	// переводим полученное кодовое слово в индексную форму для упрощения вычислений
	for (i = 0; i < n; i++)
		recd[i] = index_of[recd[i]];
	// вычисляем синдром
	//-------------------------------------------------------------------------------------------------
	for (i = 1; i <= n - k; i++)
	{
		s[i] = 0;     // инициализация s-регистра (на его вход по умолчанию поступает ноль)   
		// выполняем s[i] += recd[j]*ij т.е. берем очередной символ декодируемых данных, умножаем его
		// на порядковый номер данного символа, умноженный на номер очередного оборота и складываем
		// полученный результат с содержимым s-регистра по факту исчерпания всех декодируемых символов,
		// мы повторяем весь цикл вычислений опять – по одному разу для каждого символа четности
		for (j = 0; j < n; j++)
			if (recd[j] != -1)
				s[i] ^= alpha_to[(recd[j] + i * j) % n];
		if (s[i] != 0)
			syn_error = 1;  // если синдром не равен нулю, взводим флаг ошибки   
		// преобразуем синдром из полиномиальной формы в индексную
		s[i] = index_of[s[i]];
	}
	// коррекция ошибок
	//-------------------------------------------------------------------------------------------------
	if (syn_error)     // если есть ошибки, пытаемся их скорректировать
	{
		// вычисление полинома локатора лямбда
		//-----------------------------------------------------------------------------------------------
		// вычисляем полином локатора ошибки через итеративный алгоритм Берлекэмпа. Следуя терминологии
		// Lin and Costello (см. "Error Control Coding: Fundamentals and Applications" Prentice Hall 1983
		// ISBN 013283796) d[u] представляет собой m («мю»), выражающую расхождение (discrepancy),
		// где u = m + 1 и m есть номер шага из диапазона от –1 до 2t. У Блейхута та же самая величина
		// обозначается D(x) («дельта») и называется невязкой. l[u] представляет собой степень elp
		// для данного шага итерации, u_l[u] представляет собой разницу между номером шага и степенью elp,
		// инициализируем элементы таблицы
		d[0] = 0;        // индексная форма
		d[1] = s[1];    // индексная форма
		elp[0][0] = 0;  // индексная форма
		elp[1][0] = 1;  // полиномиальная форма   
		for (i = 1; i < n - k; i++)
		{
			elp[0][i] = -1; // индексная форма
			elp[1][i] = 0;  // полиномиальная форма
		}
		l[0] = 0; l[1] = 0; u_lu[0] = -1; u_lu[1] = 0; u = 0;
		do
		{
			u++;
			if (d[u] == -1)
			{
				l[u + 1] = l[u];
				for (i = 0; i <= l[u]; i++)
				{
					elp[u + 1][i] = elp[u][i];
					elp[u][i] = index_of[elp[u][i]];
				}
			}
			else
			{
				// поиск слов с наибольшим u_lu[q], таких что d[q]!=0
				q = u - 1;
				while ((d[q] == -1) && (q > 0))
					q--;

				// найден первый ненулевой d[q]
				if (q > 0)
				{
					j = q;
					do
					{
						j--;
						if ((d[j] != -1) && (u_lu[q] < u_lu[j]))
							q = j;
					} while (j > 0);
				};
				// как только мы найдем q, такой что d[u]!=0 и u_lu[q] есть максимум
				// запишем степень нового elp полинома
				if (l[u] > l[q] + u - q)
					l[u + 1] = l[u];
				else
					l[u + 1] = l[q] + u - q;
				// формируем новый elp(x)
				for (i = 0; i < n - k; i++)
					elp[u + 1][i] = 0;
				for (i = 0; i <= l[q]; i++)
					if (elp[q][i] != -1)
						elp[u + 1][i + u - q] = alpha_to[(d[u] + n - d[q] + elp[q][i]) % n];
				for (i = 0; i <= l[u]; i++)
				{
					elp[u + 1][i] ^= elp[u][i];
					// преобразуем старый elp в индексную форму
					elp[u][i] = index_of[elp[u][i]];
				}
			}
			u_lu[u + 1] = u - l[u + 1];
			// формируем (u + 1) невязку
			//------------------------------------------------------------------------------------------------
			if (u < n - k)  // на последней итерации расхождение не было обнаружено
			{
				if (s[u + 1] != -1)
					d[u + 1] = alpha_to[s[u + 1]];
				else
					d[u + 1] = 0;
				for (i = 1; i <= l[u + 1]; i++)
					if ((s[u + 1 - i] != -1) && (elp[u + 1][i] != 0))
						d[u + 1] ^= alpha_to[(s[u + 1 - i] + index_of[elp[u + 1][i]]) % n];
				// переводим d[u+1] в индексную форму
				d[u + 1] = index_of[d[u + 1]];
			}
		} while ((u < n - k) && (l[u + 1] <= t));
		// расчет локатора завершен
		//-----------------------------------------------------
		u++;
		if (l[u] <= t)
		{  // коррекция ошибок возможна
			// переводим elp в индексную форму
			for (i = 0; i <= l[u]; i++)
				elp[u][i] = index_of[elp[u][i]];
			// нахождение корней полинома локатора ошибки
			//----------------------------------------------
			for (i = 1; i <= l[u]; i++)
				reg[i] = elp[u][i];
			count = 0;
			for (i = 1; i <= n; i++)
			{
				q = 1;
				for (j = 1; j <= l[u]; j++)
					if (reg[j] != -1)
					{
						reg[j] = (reg[j] + j) % n;
						q ^= alpha_to[reg[j]];
					}
				if (!q)
				{  // записываем корень и индекс позиции ошибки
					root[count] = i;
					loc[count] = n - i;
					count++;
				}
			}
			if (count == l[u])
			{  // нет корней – степень elp < t ошибок   
			   // формируем полином z(x)
				for (i = 1; i <= l[u]; i++) // Z[0] всегда равно 1
				{
					if ((s[i] != -1) && (elp[u][i] != -1))
						z[i] = alpha_to[s[i]] ^ alpha_to[elp[u][i]];
					else
						if ((s[i] != -1) && (elp[u][i] == -1))
							z[i] = alpha_to[s[i]];
						else
							if ((s[i] == -1) && (elp[u][i] != -1))
								z[i] = alpha_to[elp[u][i]];
							else
								z[i] = 0;
					for (j = 1; j < i; j++)
						if ((s[j] != -1) && (elp[u][i - j] != -1))
							z[i] ^= alpha_to[(elp[u][i - j] + s[j]) % n];
					// переводим z[i] в индексную форму
					z[i] = index_of[z[i]];
				}
				// вычисление значения ошибок в позициях loc[i]
				//----------------------------------------------------------------------------------------------
				for (i = 0; i < n; i++)
				{
					err[i] = 0;
					// переводим recd[] в полиномиальную форму
					if (recd[i] != -1)
						recd[i] = alpha_to[recd[i]];
					else
						recd[i] = 0;
				}
				// сначала вычисляем числитель ошибки
				for (i = 0; i < l[u]; i++)
				{
					err[loc[i]] = 1;
					for (j = 1; j <= l[u]; j++)
						if (z[j] != -1)
							err[loc[i]] ^= alpha_to[(z[j] + j * root[i]) % n];
					if (err[loc[i]] != 0)
					{
						err[loc[i]] = index_of[err[loc[i]]];
						q = 0; // формируем знаменателькоэффициента ошибки
						for (j = 0; j < l[u]; j++)
							if (j != i)
								q += index_of[1 ^ alpha_to[(loc[j] + root[i]) % n]];
						q = q % n;
						err[loc[i]] = alpha_to[(err[loc[i]] - q + n) % n];
						// recd[i] должен быть в полиномиальной форме
						recd[loc[i]] ^= err[loc[i]];
					}
				}
			}
			else // нет корней, решение системы уравнений невозможно, т.к. степень elp >= t
			{
				// переводим recd[] в полиномиальную форму
				for (i = 0; i < n; i++)
					if (recd[i] != -1) recd[i] = alpha_to[recd[i]];
					else
						recd[i] = 0;  // выводим информационное слово как есть
			}
		else            // степень elp > t, решение невозможно
		{
			// переводим recd[] в полиномиальную форму
			for (i = 0; i < n; i++)
				if (recd[i] != -1)
					recd[i] = alpha_to[recd[i]];
				else
					recd[i] = 0; // выводим информационное слово как есть
		}
	else       // ошибок не обнаружено
		for (i = 0; i < n; i++)
			if (recd[i] != -1)
				recd[i] = alpha_to[recd[i]];
			else
				recd[i] = 0;
		}
	}
}
```

## Интерфейс с библиотекой ElByECC.DLL

Программная реализация кодера/декодера Рида-Соломона, приведенная в листингах 1, 2, достаточно наглядна, но крайне непроизводительна и нуждается в оптимизации. Как альтернативный вариант можно использовать готовые библиотеки от сторонних разработчиков, входящие в состав программных комплексов, так или иначе связанных с обработкой корректирующих кодов Рида-Соломона. Это и утилиты прожига/копирования/восстановления лазерных дисков, и драйвера ленточных накопителей (от стримера до Арвида), и различные телекоммуникационные комплексы и т. д.

Например, библиотека ElByECC.DLL, входящая в состав известного копировщика защищенных лазерных дисков Clone CD (в версии старше 5.3.4.0 она точно присутсвует). Библиотека ElByECC.DLL ориентирована на работу с секторами лазерных дисков, она может быть приспособлена и для других целей, например, построения отказоустойчивых дисковых массивов.

### GenECCAndEDC_Mode1

Функция GenECCAndEDC_Mode1 осуществляет генерацию корректирующих кодов на основе 2048-байтового блока пользовательских данных и имеет следующий прототип:
```
int GenECCAndEDC_Mode1(
    char *userdata_src, // указатель на массив из 2048 байт
    char *header_src,   // указатель на заголовок
    struct RAW_SECTOR_MODE1 *raw_sector_mode1_dst)
```    
- userdata_src – указатель на 2048-байтовый блок пользовательских данных, для которых необходимо выполнить расчет корректирующих кодов. Сами пользовательские данные в процессе выполнения функции остаются неизменными и автоматически копируются в буфер целевого сектора, где к ним добавляется 104 + 172 байт четности и 4 байта контрольной суммы.
- header_src – указатель на 4-байтовый блок, содержащий заголовок сектора. Первые три байта занимает абсолютный адрес, записанный в BCD-форме, а четвертый байт отвечает за тип сектора, которому необходимо присвоить значение 1, соответствующий режиму «корректирующие коды задействованы».
- raw_sector_mode1_dst – указатель на 2352-байтовый блок, в который будет записан сгенерированный сектор, содержащий 2048-байт пользовательских данных и 104+172 байт корректирующих кодов вместе с 4 байтами контрольной суммы и представленный следующей структурой:

``` 
Листинг 5. Структура сырого сектора
struct RAW_SECTOR_MODE1
{
   BYTE SYNC[12];        // синхрогруппа
   BYTE ADDR[3];         // абсолютный адрес сектора
   BYTE MODE;           // тип сектора
   BYTE USER_DATA[2048]; // пользовательские данные
   BYTE EDC[4];          // контрольная сумма
   BYTE ZERO[8];         // нули (не используется)
   BYTE P[172];          // P-байты четности
   BYTE Q[104];          // Q-байты четности
   };
```

При успешном завершении функция возвращает ненулевое значение и ноль в противном случае.

### CheckSector

Функция CheckSector осуществляет проверку целостности сектора по контрольной сумме и при необходимости выполняет его восстановление по избыточным кодам Рида-Соломона.
```
int CheckSector(
    struct RAW_SECTOR *sector, // указатель на секторный буфер
    int DO);      // только проверка/лечение
```     
- sector – указатель на 2352-байтовый блок данных, содержащий подопытный сектор. Лечение сектора осуществляется «вживую», т.е. непосредственно по месту возникновения ошибки. Если количество разрушенных байт превышают корректирующие способности кодов Рида-Соломона, исходные данные остаются неизменными;
- DO – флаг, нулевое значение которого указывает на запрет модификации сектора. Другими словами, соответствует режиму TEST ONLY. Ненулевое значение разрешает восстановление данных, если они действительно подверглись разрушению.

При успешном завершении функция возвращает ненулевое значение и ноль, если сектор содержит ошибку (в режиме TEST ONLY) или если данные восстановить не удалось (при вызове функции в режиме лечения). Для предотвращения возможной неоднозначности рекомендуется вызывать данную функцию в два приема. Первый раз – в режиме тестирования для проверки целостности данных, и второй раз – в режиме лечения (если это необходимо).
